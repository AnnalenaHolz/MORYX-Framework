---
uid: ResourceTypeTree
---
# Resource type tree

All plugin types within the resource management are derived from the [Resource](xref:Marvin.AbstractionLayer.Resources.Resource) class, either directly or by deriving from a subtype like [PublicResource](xref:Marvin.AbstractionLayer.Resources.PublicResource), [InteractionResource](xref:Marvin.Resources.Interaction.InteractionResource`1) or [Driver](xref:Marvin.AbstractionLayer.Drivers.Driver). Subclassing makes it possible to extend and customize existing resources or share functionality among resources by creating a common, abstract base class. Of those sub-classes `PublicResource` is especially important. The [resource managements](xref:ResourceManagement) objective is to model the CPS (cyber physical system) and make it easily accessible to other modules. Types derived from `PublicResource` or more general those implementing [IPublicResource](xref:Marvin.AbstractionLayer.Resources.IPublicResource) are the entry points into the resource graph from the facade. In the introduction the AL was compared to the `Android HAL` and its device contracts. Interfaces derived from `IPublicResource` are those contracts that can be deﬁned by applications from different domains. Other types of plugins and objects in the current version were refactored to be based on one of the resource types or fully replaced by new resource types. `Driver` and custom web-services were among the types mentioned in the beginning of this section. Resource items, the generic storage of the previous version, were replaced either by storing the information as part of a resource or by a dedicated resource. Unlike the current version of the resource management, that has a `ResourceType` database table, all type information are taken from the class definition. Base type, provided interfaces, dependencies and typed references to other resource can be expressed with C# code. The minimal required code to create a plugin for the resource management is shown in the example below.

```cs
public class MyFirstResource : Resource
{
}
```

The above example shows only the minimum required code to illustrate extensibility and lack of boilerplate code. Most resource implementations will also declare the [ResourceRegistration](xref:Marvin.AbstractionLayer.Resources.ResourceRegistrationAttribute) attribute to activate dependency injection for non-resource components like logging. During module startup all types are loaded and the bidirectional type tree is constructed using reﬂection. For each node in the tree it is possible to traverse the tree in both directions. Especially the ability to directly access all derived types is an advantage over the standard .NET reﬂection API. Besides the base and derived types,each no deal so exports the system type, its name and information how to construct instances of the type.